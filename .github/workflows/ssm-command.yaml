name: SSH and SSM Command Execution

on:
  workflow_dispatch:
    inputs:
      command:
        description: 'Command to execute on agent instances'
        required: true
        type: string
      instance_name:
        description: 'Target instance name (optional - if not provided, will target all running agents)'
        required: false
        type: string

jobs:
  execute-commands:
    runs-on: ubuntu-latest
    outputs:
      ssh_output: ${{ steps.ssh_execution.outputs.result }}
      ssm_output: ${{ steps.ssm_execution.outputs.result }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version-file: '.nvmrc'
      
      - name: Install dependencies
        run: npm install
      
      - name: Execute SSH Command
        id: ssh_execution
        run: |
          cat > execute-ssh.js << 'EOF'
          const { EC2Client, DescribeInstancesCommand } = require('@aws-sdk/client-ec2');
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');

          async function executeSSHCommand() {
            const ec2 = new EC2Client({ region: "us-east-1" });
            
            const command = process.env.COMMAND;
            const targetInstanceName = process.env.INSTANCE_NAME;
            
            if (!command) {
              throw new Error("COMMAND environment variable is required");
            }
            
            console.log(`üîç SSH: Looking for target instances...`);
            
            // Find target instances
            let instances = [];
            
            if (targetInstanceName) {
              console.log(`üéØ SSH: Targeting specific instance: ${targetInstanceName}`);
              const describeParams = {
                Filters: [
                  {
                    Name: 'tag:Name',
                    Values: [targetInstanceName]
                  },
                  {
                    Name: 'instance-state-name',
                    Values: ['running']
                  }
                ]
              };
              
              const result = await ec2.send(new DescribeInstancesCommand(describeParams));
              
              for (const reservation of result.Reservations || []) {
                for (const instance of reservation.Instances || []) {
                  if (instance.InstanceId && instance.PublicDnsName && instance.KeyName) {
                    instances.push({
                      instanceId: instance.InstanceId,
                      publicDns: instance.PublicDnsName,
                      keyName: instance.KeyName,
                      name: instance.Tags?.find(tag => tag.Key === 'Name')?.Value || 'unknown'
                    });
                  }
                }
              }
            } else {
              console.log(`üîç SSH: Discovering all running agent instances...`);
              const describeParams = {
                Filters: [
                  {
                    Name: 'tag:Name',
                    Values: ['vargas-jr*', 'pr-*']
                  },
                  {
                    Name: 'instance-state-name',
                    Values: ['running']
                  }
                ]
              };
              
              const result = await ec2.send(new DescribeInstancesCommand(describeParams));
              
              for (const reservation of result.Reservations || []) {
                for (const instance of reservation.Instances || []) {
                  if (instance.InstanceId && instance.PublicDnsName && instance.KeyName) {
                    const nameTag = instance.Tags?.find(tag => tag.Key === 'Name')?.Value || 'unknown';
                    console.log(`üìç SSH: Found instance: ${instance.InstanceId} (${nameTag})`);
                    instances.push({
                      instanceId: instance.InstanceId,
                      publicDns: instance.PublicDnsName,
                      keyName: instance.KeyName,
                      name: nameTag
                    });
                  }
                }
              }
            }
            
            if (instances.length === 0) {
              console.log(`‚ùå SSH: No target instances found`);
              if (targetInstanceName) {
                console.log(`   Searched for instance named: ${targetInstanceName}`);
              } else {
                console.log(`   Searched for running agent instances (vargas-jr*, pr-*)`);
              }
              return JSON.stringify({ success: false, message: "No instances found" });
            }
            
            console.log(`üöÄ SSH: Executing command on ${instances.length} instance(s): ${command}`);
            
            const results = [];
            
            // Execute command on all found instances via SSH
            for (const instance of instances) {
              console.log(`\nüîó SSH: Connecting to ${instance.name} (${instance.instanceId})...`);
              
              try {
                // Create temporary key file
                const keyPath = `/tmp/${instance.keyName}.pem`;
                const keyContent = process.env.SSH_PRIVATE_KEY;
                
                if (!keyContent) {
                  throw new Error("SSH_PRIVATE_KEY environment variable is required");
                }
                
                fs.writeFileSync(keyPath, keyContent, { mode: 0o600 });
                
                const sshCommand = `ssh -i ${keyPath} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 -o ConnectionAttempts=3 ubuntu@${instance.publicDns} "${command}"`;
                
                const result = execSync(sshCommand, {
                  stdio: 'pipe',
                  encoding: 'utf8',
                  timeout: 300000 // 5 minutes
                });
                
                console.log(`‚úÖ SSH: Command completed successfully on ${instance.name}`);
                if (result.trim()) {
                  console.log(`üìÑ SSH Output:`);
                  result.split('\n').forEach(line => {
                    if (line.trim()) {
                      console.log(`   ${line}`);
                    }
                  });
                } else {
                  console.log(`   (no output)`);
                }
                
                results.push({
                  instanceId: instance.instanceId,
                  name: instance.name,
                  success: true,
                  output: result.trim(),
                  error: null
                });
                
                // Clean up key file
                fs.unlinkSync(keyPath);
                
              } catch (error) {
                console.error(`‚ùå SSH: Error executing command on ${instance.name}: ${error.message}`);
                
                results.push({
                  instanceId: instance.instanceId,
                  name: instance.name,
                  success: false,
                  output: null,
                  error: error.message
                });
                
                // Clean up key file if it exists
                const keyPath = `/tmp/${instance.keyName}.pem`;
                if (fs.existsSync(keyPath)) {
                  fs.unlinkSync(keyPath);
                }
              }
            }
            
            console.log(`\nüèÅ SSH: Command execution completed`);
            return JSON.stringify({ success: true, results });
          }

          executeSSHCommand().then(result => {
            console.log(`::set-output name=result::${result}`);
          }).catch(error => {
            console.error(error);
            console.log(`::set-output name=result::${JSON.stringify({ success: false, error: error.message })}`);
          });
          EOF
          
          node execute-ssh.js
        env:
          COMMAND: ${{ github.event.inputs.command }}
          INSTANCE_NAME: ${{ github.event.inputs.instance_name }}
          SSH_PRIVATE_KEY: ${{ secrets.VARGASJR_SSH_PRIVATE_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
      
      - name: Execute SSM Command
        id: ssm_execution
        run: |
          cat > execute-ssm.js << 'EOF'
          const { SSM } = require('@aws-sdk/client-ssm');
          const { EC2Client, DescribeInstancesCommand } = require('@aws-sdk/client-ec2');

          async function executeSSMCommand() {
            const ssm = new SSM({ region: "us-east-1" });
            const ec2 = new EC2Client({ region: "us-east-1" });
            
            const command = process.env.COMMAND;
            const targetInstanceName = process.env.INSTANCE_NAME;
            
            if (!command) {
              throw new Error("COMMAND environment variable is required");
            }
            
            console.log(`üîç SSM: Looking for target instances...`);
            
            // Find target instances
            let instanceIds = [];
            
            if (targetInstanceName) {
              console.log(`üéØ SSM: Targeting specific instance: ${targetInstanceName}`);
              const describeParams = {
                Filters: [
                  {
                    Name: 'tag:Name',
                    Values: [targetInstanceName]
                  },
                  {
                    Name: 'instance-state-name',
                    Values: ['running']
                  }
                ]
              };
              
              const result = await ec2.send(new DescribeInstancesCommand(describeParams));
              
              for (const reservation of result.Reservations || []) {
                for (const instance of reservation.Instances || []) {
                  if (instance.InstanceId) {
                    instanceIds.push({
                      instanceId: instance.InstanceId,
                      name: instance.Tags?.find(tag => tag.Key === 'Name')?.Value || 'unknown'
                    });
                  }
                }
              }
            } else {
              console.log(`üîç SSM: Discovering all running agent instances...`);
              const describeParams = {
                Filters: [
                  {
                    Name: 'tag:Name',
                    Values: ['vargas-jr*', 'pr-*']
                  },
                  {
                    Name: 'instance-state-name',
                    Values: ['running']
                  }
                ]
              };
              
              const result = await ec2.send(new DescribeInstancesCommand(describeParams));
              
              for (const reservation of result.Reservations || []) {
                for (const instance of reservation.Instances || []) {
                  if (instance.InstanceId) {
                    const nameTag = instance.Tags?.find(tag => tag.Key === 'Name')?.Value || 'unknown';
                    console.log(`üìç SSM: Found instance: ${instance.InstanceId} (${nameTag})`);
                    instanceIds.push({
                      instanceId: instance.InstanceId,
                      name: nameTag
                    });
                  }
                }
              }
            }
            
            if (instanceIds.length === 0) {
              console.log(`‚ùå SSM: No target instances found`);
              if (targetInstanceName) {
                console.log(`   Searched for instance named: ${targetInstanceName}`);
              } else {
                console.log(`   Searched for running agent instances (vargas-jr*, pr-*)`);
              }
              return JSON.stringify({ success: false, message: "No instances found" });
            }
            
            console.log(`üöÄ SSM: Executing command on ${instanceIds.length} instance(s): ${command}`);
            
            const results = [];
            
            // Execute command on all found instances
            for (const instance of instanceIds) {
              console.log(`\nüì° SSM: Executing on ${instance.name} (${instance.instanceId})...`);
              
              try {
                const commandResult = await ssm.sendCommand({
                  InstanceIds: [instance.instanceId],
                  DocumentName: "AWS-RunShellScript",
                  Parameters: {
                    commands: [command],
                  },
                  TimeoutSeconds: 300,
                });

                const commandId = commandResult.Command?.CommandId;
                if (!commandId) {
                  throw new Error("Failed to get command ID from SSM");
                }

                console.log(`‚è≥ SSM: Waiting for command completion (ID: ${commandId})...`);

                let pollAttempts = 0;
                const maxPollAttempts = 60;
                
                while (pollAttempts < maxPollAttempts) {
                  await new Promise(resolve => setTimeout(resolve, 5000));
                  
                  const outputResult = await ssm.getCommandInvocation({
                    CommandId: commandId,
                    InstanceId: instance.instanceId,
                  });

                  if (outputResult.Status === "Success") {
                    console.log(`‚úÖ SSM: Command completed successfully on ${instance.name}`);
                    const output = outputResult.StandardOutputContent || "";
                    if (output.trim()) {
                      console.log(`üìÑ SSM Output:`);
                      output.split('\n').forEach(line => {
                        if (line.trim()) {
                          console.log(`   ${line}`);
                        }
                      });
                    } else {
                      console.log(`   (no output)`);
                    }
                    
                    results.push({
                      instanceId: instance.instanceId,
                      name: instance.name,
                      success: true,
                      output: output.trim(),
                      error: null
                    });
                    break;
                  } else if (outputResult.Status === "Failed") {
                    const errorDetails = outputResult.StandardErrorContent || "No error details available";
                    const outputDetails = outputResult.StandardOutputContent || "No output";
                    console.log(`‚ùå SSM: Command failed on ${instance.name}`);
                    console.log(`üìÑ Error: ${errorDetails}`);
                    if (outputDetails.trim()) {
                      console.log(`üìÑ Output: ${outputDetails}`);
                    }
                    
                    results.push({
                      instanceId: instance.instanceId,
                      name: instance.name,
                      success: false,
                      output: outputDetails.trim(),
                      error: errorDetails
                    });
                    break;
                  } else if (outputResult.Status === "Cancelled" || outputResult.Status === "TimedOut") {
                    console.log(`‚ö†Ô∏è SSM: Command ${outputResult.Status.toLowerCase()} on ${instance.name}`);
                    
                    results.push({
                      instanceId: instance.instanceId,
                      name: instance.name,
                      success: false,
                      output: null,
                      error: `Command ${outputResult.Status.toLowerCase()}`
                    });
                    break;
                  }
                  
                  pollAttempts++;
                  if (pollAttempts < maxPollAttempts) {
                    console.log(`‚è≥ SSM: Still waiting... (${pollAttempts}/${maxPollAttempts})`);
                  }
                }
                
                if (pollAttempts >= maxPollAttempts) {
                  console.log(`‚ö†Ô∏è SSM: Command timed out after 5 minutes on ${instance.name}`);
                  results.push({
                    instanceId: instance.instanceId,
                    name: instance.name,
                    success: false,
                    output: null,
                    error: "Command timed out after 5 minutes"
                  });
                }
              } catch (error) {
                console.error(`‚ùå SSM: Error executing command on ${instance.name}: ${error.message}`);
                results.push({
                  instanceId: instance.instanceId,
                  name: instance.name,
                  success: false,
                  output: null,
                  error: error.message
                });
              }
            }
            
            console.log(`\nüèÅ SSM: Command execution completed`);
            return JSON.stringify({ success: true, results });
          }

          executeSSMCommand().then(result => {
            console.log(`::set-output name=result::${result}`);
          }).catch(error => {
            console.error(error);
            console.log(`::set-output name=result::${JSON.stringify({ success: false, error: error.message })}`);
          });
          EOF
          
          node execute-ssm.js
        env:
          COMMAND: ${{ github.event.inputs.command }}
          INSTANCE_NAME: ${{ github.event.inputs.instance_name }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
      
      - name: Display Results Summary
        run: |
          echo "## SSH Execution Results"
          echo '${{ steps.ssh_execution.outputs.result }}'
          echo ""
          echo "## SSM Execution Results"
          echo '${{ steps.ssm_execution.outputs.result }}'
